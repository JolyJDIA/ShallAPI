package jolyjdia.api.database;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutorService;

public abstract class MySqlExecutor implements SqlConnection {
    private final String username, password, url;
    private final ExecutorService executorService;

    protected MySqlExecutor(String username, String password, String url, ExecutorService executorService) {
        this.username = username;
        this.password = password;
        this.url = url;
        this.executorService = executorService;
    }
    public final String getPassword() {
        return password;
    }

    public final String getUrl() {
        return url;
    }

    public final String getUsername() {
        return username;
    }

    public abstract void preparedStatement(final String sql,
            StatementConsumer<? super PreparedStatement> statement
    );
    //ЗАКРОЙ ЕБАЛО
    @Deprecated
    public abstract ResultSet preparedResultSet(final String sql,
            StatementConsumer<? super PreparedStatement> statement
    );

    public abstract <T> T preparedExecuteQuery(final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            ResultConsumer<? extends T> result
    );
    public abstract void preparedExecuteQuery(final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            StatementConsumer<? super ResultSet> result
    );

    public abstract int preparedAutoGeneratedKeys(final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            int autoGeneratedKeys
    );

    public abstract void unpreparedExecute(final String sql);

    //ЗАКРОЙ ЕБАЛО
    @Deprecated
    public abstract ResultSet unpreparedExecuteQuery(final String sql);

    public abstract void unpreparedExecuteQuery(final String sql,
            StatementConsumer<? super ResultSet> result
    );

    /**
     * Асинхронные методы
     * ForkJoin -> CachedThreadPool
     */
    public void asyncPreparedStatement(final String sql,
            StatementConsumer<? super PreparedStatement> statement) {
        execute(() -> preparedStatement(sql, statement));
    }
    //ЗАКРОЙ ЕБАЛО
    @Deprecated
    public CompletionStage<ResultSet> asyncPreparedResultSet(final String sql,
            StatementConsumer<? super PreparedStatement> statement) {
        return submit(() -> preparedResultSet(sql, statement));
    }
    public <U> CompletionStage<U> asyncPreparedExecuteQuery(final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            ResultConsumer<? extends U> result) {
        return submit(() -> preparedExecuteQuery(sql, statement, result));
    }
    public CompletionStage<Void> asyncPreparedExecuteQuery(final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            StatementConsumer<? super ResultSet> result) {
        return execute(() -> preparedExecuteQuery(sql, statement, result));
    }
    public CompletionStage<Integer> asyncPreparedAutoGeneratedKeys(final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            int autoGeneratedKeys) {
        return submit(() -> preparedAutoGeneratedKeys(sql, statement, autoGeneratedKeys));
    }
    public CompletionStage<Void> asyncUnpreparedExecute(final String sql) {
        return execute(() -> unpreparedExecute(sql));
    }
    //ЗАКРОЙ ЕБАЛО
    @Deprecated
    public CompletionStage<ResultSet> asyncUnpreparedExecuteQuery(final String sql) {
        return submit(() -> unpreparedExecuteQuery(sql));
    }
    public CompletionStage<Void> asyncUnpreparedExecuteQuery(final String sql,
            StatementConsumer<? super ResultSet> result) {
        return execute(() -> unpreparedExecuteQuery(sql, result));
    }

    public CompletionStage<Void> execute(Runnable runnable) {
        return CompletableFuture.runAsync(() -> {
            long start = System.currentTimeMillis();
            runnable.run();
            long end = System.currentTimeMillis() - start;
            System.out.println(Thread.currentThread().getName()+"[AsyncSqlQueryExecutor] EXECUTE loaded "+end+" ms");
        }, executorService);
    }
    public <U> CompletionStage<U> submit(Callable<? extends U> callable) {
        return new CompletableFuture<U>().completeAsync(() -> {
            long start = 0;
            try {
                start = System.currentTimeMillis();
                return callable.call();
            } catch (Exception e) {
                throw new RuntimeException("[AsyncSqlQueryExecutor] Неизвестная ошибка в получении результата", e);
            } finally {
                long end = System.currentTimeMillis() - start;
                System.out.println(Thread.currentThread().getName()+"[AsyncSqlQueryExecutor] SUBMIT loaded "+end+" ms ");
            }
        }, executorService);
    }
}
