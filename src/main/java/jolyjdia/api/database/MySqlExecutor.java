package jolyjdia.api.database;

import jolyjdia.utils.BukkitUtils;
import org.jetbrains.annotations.NotNull;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

public abstract class MySqlExecutor implements SqlConnection {
    private final String username, password, url;

    protected MySqlExecutor(String username, String password, String url) {
        this.username = username;
        this.password = password;
        this.url = url;
    }
    public final String getPassword() {
        return password;
    }

    public final String getUrl() {
        return url;
    }

    public final String getUsername() {
        return username;
    }

    public abstract void preparedStatement(
            final String sql,
            StatementConsumer<? super PreparedStatement> statement
    );
    public abstract void preparedStatementExecute(final String sql);

    public abstract <T> T preparedExecuteQuery(
            final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            ResultConsumer<? extends T> result
    );
    public abstract void preparedExecuteQuery(
            final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            StatementConsumer<? super ResultSet> result
    );

    public abstract int preparedAutoGeneratedKeys(
            final String sql,
            StatementConsumer<? super PreparedStatement> statement,
            int autoGeneratedKeys
    );

    public abstract void unpreparedExecute(final String sql);

    public abstract void unpreparedExecuteQuery(final String sql,
                                                StatementConsumer<? super ResultSet> result
    );
    public abstract void unpreparedStatement(StatementConsumer<? super Statement> statement);

    /**
     * Асинхронные методы
     */
    /**
     * Асинхронные методы
     * ForkJoin -> CachedThreadPool
     */
    public void asyncPreparedStatement(final String sql,
                                       StatementConsumer<? super PreparedStatement> statement) {
        execute(() -> preparedStatement(sql, statement));
    }
    public void asyncPreparedStatementExecute(final String sql) {
        execute(() -> preparedStatementExecute(sql));
    }
    public <U> CompletionStage<U> asyncPreparedExecuteQuery(final String sql,
                                                            StatementConsumer<? super PreparedStatement> statement,
                                                            ResultConsumer<? extends U> result) {
        return submit(() -> preparedExecuteQuery(sql, statement, result));
    }
    public CompletionStage<Void> asyncPreparedExecuteQuery(final String sql,
                                                           StatementConsumer<? super PreparedStatement> statement,
                                                           StatementConsumer<? super ResultSet> result) {
        return execute(() -> preparedExecuteQuery(sql, statement, result));
    }
    public CompletionStage<Integer> asyncPreparedAutoGeneratedKeys(final String sql,
                                                                   StatementConsumer<? super PreparedStatement> statement,
                                                                   int autoGeneratedKeys) {
        return submit(() -> preparedAutoGeneratedKeys(sql, statement, autoGeneratedKeys));
    }
    public CompletionStage<Void> asyncUnpreparedExecute(final String sql) {
        return execute(() -> unpreparedExecute(sql));
    }
    public CompletionStage<Void> asyncUnpreparedExecuteQuery(final String sql,
                                                             StatementConsumer<? super ResultSet> result) {
        return execute(() -> unpreparedExecuteQuery(sql, result));
    }
    public CompletionStage<Void> asyncUnpreparedStatement(StatementConsumer<? super Statement> statement) {
        return execute(() -> unpreparedStatement(statement));
    }

    public static @NotNull CompletionStage<Void> execute(Runnable runnable) {
        CompletableFuture<Void> d = new CompletableFuture<>();
        BukkitUtils.runAsync(() -> {
            runnable.run();
            d.complete(null);
        });
        return d;
    }
    public static <U> @NotNull CompletionStage<U> submit(Callable<? extends U> callable) {
        CompletableFuture<U> d = new CompletableFuture<>();
        BukkitUtils.runAsync(() -> {
            long start = 0;
            try {
                start = System.currentTimeMillis();
                d.complete(callable.call());
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                long end = System.currentTimeMillis() - start;
                System.out.println(Thread.currentThread().getName()+"[AsyncSqlQueryExecutor] SUBMIT loaded "+end+" ms ");
            }
        });
        return d;
    }

    /**public @NotNull CompletionStage<Void> execute(Runnable runnable) {
        return CompletableFuture.runAsync(() -> {
            long start = System.currentTimeMillis();
            runnable.run();
            long end = System.currentTimeMillis() - start;
            System.out.println(Thread.currentThread().getName()+"[AsyncSqlQueryExecutor] EXECUTE loaded "+end+" ms");
        }, executorService);
    }
    public <U> @NotNull CompletionStage<U> submit(Callable<? extends U> callable) {
        return CompletableFuture.supplyAsync(() -> {
            long start = 0;
            try {
                start = System.currentTimeMillis();
                return callable.call();
            } catch (Exception e) {
                throw new RuntimeException("[AsyncSqlQueryExecutor] Неизвестная ошибка в получении результата", e);
            } finally {
                long end = System.currentTimeMillis() - start;
                System.out.println(Thread.currentThread().getName()+"[AsyncSqlQueryExecutor] SUBMIT loaded "+end+" ms ");
            }
        }, executorService);
    }*/
}
